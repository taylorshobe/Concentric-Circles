import textwrap

def generate_final_sql(cleaned_data_df):
    try:
        final_sql_list = []
        
        # Get the unique blocks in the data
        blocks = cleaned_data_df['block_id'].unique()
        query_key = cleaned_data_df['query_key'].iloc[0]

        # Split blocks into include and exclude groups
        include_blocks = [block_id for block_id in blocks if cleaned_data_df[cleaned_data_df['block_id'] == block_id]['phrase_operator'].values[0] == 'INCLUDE MATCHES']
        exclude_blocks = [block_id for block_id in blocks if cleaned_data_df[cleaned_data_df['block_id'] == block_id]['phrase_operator'].values[0] == 'EXCLUDE MATCHES']

        # Sort Blocks
        include_blocks.sort()
        exclude_blocks.sort()
        
        # Group by block_id to process each block of phrases
        for block_id, block_group in cleaned_data_df.groupby('block_id'):
            # Check if block has a single Phrase Group and is standalone
            is_standalone = block_group['standalone_pg'].iloc[0]
            prefix = "t1_" if is_standalone else ""
            
            # Identify the type of operator being used for the block
            if block_group['operator'].iloc[0].lower() == 'none':
                final_sql_list.append(generate_none_sql(block_group, block_id))
                
            elif block_group['operator'].iloc[0].lower() in ['and', 'near']:
                final_sql_list.append(generate_and_near_sql(block_group, block_id, prefix))
                
            else:
                for _, row in block_group.iterrows():
                    final_sql_list.append(generate_phrase_sql(row, block_id, prefix))
        
        # Join the individual SQLs based on your requirements
        all_sql = "\n\nUNION ALL\n\n".join(final_sql_list)
        any_sql = "\n\nUNION\n\n".join(final_sql_list)
        
        # Return the final SQL based on the block combo logic
        if cleaned_data_df['block_combo_logic'].values[0] == 'ALL BLOCKS':
            final_sql = f"""CREATE OR REPLACE TEMPORARY TABLE {query_key} AS (\n\n{all_sql}\n)"""
            print(f"Generated 'all blocks' SQL:\n\n{final_sql}\n")
            return final_sql

        elif cleaned_data_df['block_combo_logic'].values[0] == 'ANY BLOCK':
            final_sql = f"""CREATE OR REPLACE TEMPORARY TABLE {query_key} AS (\nSELECT * FROM (\n\n{any_sql})\nGROUP BY r_id, pcd, seq, utterance\n)\n"""
            print(f"Generated 'any block' SQL:\n\n{final_sql}\n")
            return final_sql
        
    except Exception as e:
        print(f"Error generating final SQL: {str(e)}")
        return None
