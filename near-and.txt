

def generate_intersection_cte(inclusion_blocks, exclusion_blocks):
    """
    Generates the intersection CTE SQL. 
    First, it finds the intersection of all inclusionary blocks.
    Then, it excludes the results present in any exclusionary blocks.
    """
    # INNER JOIN for each inclusionary block after the first one
    inclusion_joins = "\n".join([f"INNER JOIN {block}_transformed_results AS {block}\nON A.r_id = {block}.r_id" for block in inclusion_blocks[1:]])
    
    # LEFT JOIN for each exclusionary block
    exclusion_joins = "\n".join([f"LEFT JOIN {block}_transformed_results AS {block}\nON A.r_id = {block}.r_id" for block in exclusion_blocks])
    
    # Conditions to ensure r_ids from exclusionary blocks are excluded
    exclusion_conditions = " AND ".join([f"{block}.r_id IS NULL" for block in exclusion_blocks])
    
    cte_sql = f"""
WITH intersection AS (
    SELECT A.* 
    FROM {inclusion_blocks[0]}_transformed_results AS A
    {inclusion_joins}
    {exclusion_joins}
    WHERE {exclusion_conditions}
)
"""
    return cte_sql

def generate_final_sql():
    cte = generate_intersection_cte(inclusion_blocks, exclusion_blocks)
    union_sql = generate_union_sql(inclusion_blocks)

    final_sql = f"""
{cte}
CREATE OR REPLACE TEMPORARY TABLE {query_key} AS
SELECT *
FROM (
    {union_sql}
) T1
GROUP BY {', '.join(all_columns)}
    """

    logging.info(f"Generated SQL:\n{final_sql}")
    return final_sql
