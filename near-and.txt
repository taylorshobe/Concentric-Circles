
# Create SQL for "AND" & "NEAR"
def generate_and_near_sql(group, block_id):
    block_combo_logic = group['block_combo_logic'].iloc[0]
    block_operator = group['operator'].iloc[0]

    # Loop over each row in the group and generate a SQL query
    include_sql_queries = []
    exclude_sql_queries = []

    for i, row in group.iterrows():
        sql = generate_phrase_sql(row, block_id)

        # ... [rest of the code in this loop is unchanged]

    # Join all include queries into one
    if include_sql_queries:
        include_subqueries = [f"({sql}) AS t{i}\n" for i, sql in enumerate(include_sql_queries, start=1)]
        select_columns = ",\n".join([f"t{i}.seq AS block_id_{block_id}_t{i}_seq, t{i}.utterance AS block_id_{block_id}_t{i}_utterance" for i in range(1, len(include_subqueries)+1)])
        join_conditions = []
        if len(include_subqueries) > 1:
            if block_operator.lower() == 'and':
                join_conditions = [f'\nINNER JOIN\n\n{subquery} \nON t1.r_id = t{i+1}.r_id \n' for i, subquery in enumerate(include_subqueries[1:], start=1)]
            elif block_operator.lower() == 'near':
                join_conditions = [f'\nINNER JOIN\n\n{subquery} \nON t1.r_id = t{i+1}.r_id \nAND ABS(t1.seq - t{i+1}.seq) <= {prox_m_seconds}\n' for i, subquery in enumerate(include_subqueries[1:], start=1)]
        from_clause = f"FROM {include_subqueries[0]} {' '.join(join_conditions)}"
    else:
        from_clause = ""
        select_columns = ""

    # ... [rest of the code for excluding blocks is unchanged]

    # Construct the final SQL
    final_sql = textwrap.dedent(f"""
SELECT
  t1.r_id,
  '{block_id}' AS block_id,
  '{block_combo_logic}' AS block_combo_logic,
  t1.phrase_operator,
  {select_columns}
{from_clause}
{exclude_on_conditions} 
{where_condition} 
""")
    return final_sql





def generate_final_sql(clean_data_df):

    # Get the unique blocks in the data
    blocks = clean_data_df['block_id'].unique()
    query_key = clean_data_df['query_key'].iloc[0]

    # Split blocks into include and exclude groups
    include_blocks = [block_id for block_id in blocks if clean_data_df[clean_data_df['block_id'] == block_id]['phrase_operator'].values[0] == 'INCLUDE MATCHES']
    exclude_blocks = [block_id for block_id in blocks if clean_data_df[clean_data_df['block_id'] == block_id]['phrase_operator'].values[0] == 'EXCLUDE MATCHES']

    # Sort Blocks
    include_blocks.sort()
    exclude_blocks.sort()

    # Check if any of the include Blocks are empty and return early if so
    if not include_blocks:
        print("No results found for the given Block ID. Exiting ...")
        return ""

    # Columns for grouping by and selecting
    select_columns = ["r_id", "pcd", "seq", "utterance"]
    for block_id in include_blocks:
        select_columns.append(f"{block_id}_seq")
        select_columns.append(f"{block_id}_utterance")

    select_clause = ", ".join(select_columns)

    def construct_sql(base_query, include_blocks, join_type, additional_clause):
        # Construct the main SQL
        sql = f"{base_query}\n"

        # Handle included blocks
        if join_type == "UNION ALL":
            inclusions = "\n".join([f"{join_type}\nSELECT r_id, pcd, seq, utterance\nFROM {block_id}_results" for block_id in include_blocks[1:]])
        else:
            inclusions = "\n".join([f"{join_type}\n{block_id}_results AS t{i+2} ON t1.r_id = t{i+2}.r_id" for i, block_id in enumerate(include_blocks[1:])])
        sql += inclusions

        # Handle excluded blocks
        where_clause = "\nWHERE "
        for i, block_id in enumerate(exclude_blocks):
            sql += f"\nLEFT JOIN {block_id}_results AS te{i+1}\nON t1.r_id = te{i+1}.r_id"
            where_clause += f"te{i+1}.r_id IS NULL\nAND "

        if exclude_blocks:
            sql += where_clause.rstrip("AND ")

        return f"{sql}{additional_clause}"

    # Generate 'all' and 'any' SQL based on the definitions
    all_sql = construct_sql(
        base_query=f"SELECT {select_clause}\nFROM {include_blocks[0]}_results AS t1",
        include_blocks=include_blocks,
        join_type="INNER JOIN",
        additional_clause=f"\nGROUP BY {select_clause}"
    )

    any_sql = construct_sql(
        base_query=f"SELECT {select_clause}\nFROM {include_blocks[0]}_results AS t1",
        include_blocks=include_blocks,
        join_type="UNION ALL",
        additional_clause=""
    )

    # Return the final SQL based on the block combo logic
    if clean_data_df['block_combo_logic'].values[0] == 'ALL BLOCKS':
        final_sql = f"""CREATE OR REPLACE TEMPORARY TABLE {query_key} AS (\n\n{all_sql}\n)"""
        print(f"Generated 'all blocks' SQL:\n\n{final_sql}\n")
        return final_sql

    elif clean_data_df['block_combo_logic'].values[0] == 'ANY BLOCK':
        final_sql = f"""CREATE OR REPLACE TEMPORARY TABLE {query_key} AS (\nSELECT * FROM (\n\n{any_sql})\nGROUP BY {select_clause}\n)\n"""
        print(f"Generated 'any block' SQL:\n\n{final_sql}\n")
        return final_sql










def generate_final_sql(clean_data_df):
    ...
    # Rest of the code
    ...

    # Construct the final SQL
    if clean_data_df['block_combo_logic'].iloc[0] == 'all blocks':
        all_sql = construct_final_sql(f"SELECT DISTINCT * FROM ({combined_sql}) AS t1", exclude_blocks)
        final_sql = f"CREATE OR REPLACE TEMPORARY TABLE {query_id} AS (\n{all_sql}\n)"

    elif clean_data_df['block_combo_logic'].iloc[0] == 'any block':
        any_sql = construct_final_sql(f"SELECT DISTINCT * FROM ({combined_sql}) AS t1", exclude_blocks)
        final_sql = f"CREATE OR REPLACE TEMPORARY TABLE {query_id} AS (\n{any_sql}\n)"

    return final_sql
















