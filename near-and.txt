import logging

def generate_final_sql(block_ids, query_key, clean_data_df):
    """
    This function generates the SQL to standardize the tables for each block and combine them.
    """
    standardized_sqls = []
    ctes = []

    logging.info(f"Generating final SQL for query key: {query_key}")
    
    for block_id in block_ids:
        logging.info(f"Standardizing temp table for block_id: {block_id}")
        table_name = f"{block_id}_transformed_results"
        ctes.append(f"{table_name} AS (\n{standardize_temp_table(block_id)}\n)")
        standardized_sqls.append(f"SELECT * FROM {table_name}")

    if 'ANY BLOCK' in clean_data_df['block_combo_logic'].values:
        logging.info("Combining using 'ANY BLOCK' logic.")
        main_query = "\nUNION ALL\n".join(standardized_sqls)
    else:
        logging.info("Combining using 'ALL BLOCKS' logic.")
        inclusion_blocks = []
        exclusion_blocks = []
        
        for block_id in block_ids:
            block_operator = clean_data_df[clean_data_df['block_id'] == block_id]['phrase_operator'].iloc[0]
            if block_operator == 'INCLUDE MATCHES':
                inclusion_blocks.append(f"{block_id}_transformed_results")
            else:
                exclusion_blocks.append(f"{block_id}_transformed_results")
        
        all_inclusions = " \nINNER JOIN\n ".join([f"{block} USING (r_id)" for block in inclusion_blocks])
        logging.info(f"Intersecting tables: {', '.join(inclusion_blocks)}")
        
        if exclusion_blocks:
            all_exclusions = " OR ".join([f"r_id IN (SELECT r_id FROM {block})" for block in exclusion_blocks])
            main_query = f"SELECT * FROM {all_inclusions} WHERE NOT ({all_exclusions})"
            logging.info(f"Excluding records from tables: {', '.join(exclusion_blocks)}")
        else:
            main_query = f"SELECT * FROM {all_inclusions}"

    cte_section = ",\n".join(ctes)
    final_sql = f"WITH\n{cte_section}\n{main_query}"

    logging.info(f"Generated SQL:\n{final_sql}")
    return final_sql





def execute_final_sql(sql, query_key):
    """
    This function executes the given SQL and stores the result into a new temp table with the name {query_key}.
    """
    try:
        # Create a new table using the provided query_key as its name
        create_table_sql = f"""
        CREATE OR REPLACE TABLE `{query_key}` AS {sql}
        """
        logging.info(f"Executing SQL to create final table: {query_key}")
        gcp_cursor.execute(create_table_sql)
        logging.info(f"Successfully created table: {query_key}")
    except Exception as e:
        logging.error(f"Error while creating table {query_key}. Error: {e}")


# Call this downstream after calling the generate_final_sql function:
final_sql_script = generate_final_sql(block_ids, query_key, clean_data_df)
execute_final_sql(final_sql_script, query_key)

