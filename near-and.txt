import logging

def generate_final_sql(clean_data_df, query_key):

    def generate_union_sql(inclusion_blocks):
        """
        Generates the UNION ALL SQL for the provided inclusionary blocks.
        """
        return "\nUNION ALL\n".join([f"SELECT * FROM {block}_transformed_results" for block in inclusion_blocks])

    def generate_intersection_cte(inclusion_blocks, exclusion_blocks):
        """
        Generates the intersection CTE SQL. 
        First, it finds the intersection of all inclusionary blocks.
        Then, it excludes the results present in any exclusionary blocks.
        """
        # INNER JOIN for each inclusionary block after the first one
        inclusion_joins = "\n".join([f"INNER JOIN {block}_transformed_results AS {block}\nON A.r_id = {block}.r_id" for block in inclusion_blocks[1:]])
        
        # LEFT JOIN for each exclusionary block
        exclusion_joins = "\n".join([f"LEFT JOIN {block}_transformed_results AS {block}\nON A.r_id = {block}.r_id" for block in exclusion_blocks])
        
        # Conditions to ensure r_ids from exclusionary blocks are excluded
        exclusion_conditions = " AND ".join([f"{block}.r_id IS NULL" for block in exclusion_blocks])
        
        cte_sql = f"""
WITH intersection AS (
    SELECT A.* 
    FROM {inclusion_blocks[0]}_transformed_results AS A
    {inclusion_joins}
    {exclusion_joins}
    WHERE {exclusion_conditions}
)
"""
        return cte_sql

    # Extracting block IDs directly from the provided DataFrame
    block_ids = clean_data_df['block_id'].unique().tolist()

    # Establishing lists for inclusionary and exclusionary blocks
    inclusion_blocks = []
    exclusion_blocks = []
    for block_id in block_ids:
        phrase_operator = clean_data_df[clean_data_df['block_id'] == block_id]['phrase_operator'].iloc[0]
        if phrase_operator == 'INCLUDE MATCHES':
            inclusion_blocks.append(block_id)
        else:
            exclusion_blocks.append(block_id)

    cte = generate_intersection_cte(inclusion_blocks, exclusion_blocks)
    union_sql = generate_union_sql(inclusion_blocks)
    
    all_columns = ['T1.r_id', 'T1.block_id', 'T1.block_combo_logic', 'T1.phrase_group_id', 'T1.phrase_operator', 'T1.pcd', 'T1.seq', 'T1.utterance']
    final_sql = f"""
{cte}
CREATE OR REPLACE TEMPORARY TABLE {query_key} AS
SELECT *
FROM (
    {union_sql}
) T1
GROUP BY {', '.join(all_columns)}
    """
    logging.info(f"Generated SQL:\n{final_sql}")

    return final_sql
