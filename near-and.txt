
# Create SQL for "AND" & "NEAR"
def generate_and_near_sql(group, block_id):
    block_combo_logic = group['block_combo_logic'].iloc[0]
    block_operator = group['operator'].iloc[0]

    # Loop over each row in the group and generate a SQL query
    include_sql_queries = []
    exclude_sql_queries = []

    for i, row in group.iterrows():
        sql = generate_phrase_sql(row, block_id)

        # ... [rest of the code in this loop is unchanged]

    # Join all include queries into one
    if include_sql_queries:
        include_subqueries = [f"({sql}) AS t{i}\n" for i, sql in enumerate(include_sql_queries, start=1)]
        select_columns = ",\n".join([f"t{i}.seq AS block_id_{block_id}_t{i}_seq, t{i}.utterance AS block_id_{block_id}_t{i}_utterance" for i in range(1, len(include_subqueries)+1)])
        join_conditions = []
        if len(include_subqueries) > 1:
            if block_operator.lower() == 'and':
                join_conditions = [f'\nINNER JOIN\n\n{subquery} \nON t1.r_id = t{i+1}.r_id \n' for i, subquery in enumerate(include_subqueries[1:], start=1)]
            elif block_operator.lower() == 'near':
                join_conditions = [f'\nINNER JOIN\n\n{subquery} \nON t1.r_id = t{i+1}.r_id \nAND ABS(t1.seq - t{i+1}.seq) <= {prox_m_seconds}\n' for i, subquery in enumerate(include_subqueries[1:], start=1)]
        from_clause = f"FROM {include_subqueries[0]} {' '.join(join_conditions)}"
    else:
        from_clause = ""
        select_columns = ""

    # ... [rest of the code for excluding blocks is unchanged]

    # Construct the final SQL
    final_sql = textwrap.dedent(f"""
SELECT
  t1.r_id,
  '{block_id}' AS block_id,
  '{block_combo_logic}' AS block_combo_logic,
  t1.phrase_operator,
  {select_columns}
{from_clause}
{exclude_on_conditions} 
{where_condition} 
""")
    return final_sql





import textwrap

# ... [Your other function definitions like generate_phrase_sql() and generate_and_near_sql() here] ...

def generate_final_sql(clean_data_df):
    # Get the unique blocks in the data
    blocks = clean_data_df['block_id'].unique()
    query_id = clean_data_df['query_id'].iloc[0]

    # Split blocks into include and exclude groups
    include_blocks = sorted([block for block in blocks if clean_data_df[clean_data_df['block_id'] == block]['phrase_operator'].iloc[0] == 'include matches'])
    exclude_blocks = [block for block in blocks if clean_data_df[clean_data_df['block_id'] == block]['phrase_operator'].iloc[0] == 'exclude matches']

    # Columns for grouping by and selecting
    select_columns = ["r_id"]
    for block in include_blocks:
        select_columns.append(f"{block}_seq")
        select_columns.append(f"{block}_utterance")

    select_clause = ", ".join(select_columns)

    # Iterate over blocks and create the SQL for each block
    block_sql = []

    for block in include_blocks:
        block_data = clean_data_df[clean_data_df['block_id'] == block]
        sql = generate_and_near_sql(block_data, block)
        if sql:
            block_sql.append(sql)

    combined_sql = "\nUNION ALL\n".join(block_sql)

    def construct_final_sql(base_query, exclude_blocks):
        sql = f"{base_query}\n"

        # Handle excluded blocks
        where_clause = "\nWHERE "
        for i, block in enumerate(exclude_blocks):
            sql += f"\nLEFT JOIN {block}_results AS te{i+1}\nON t1.r_id = te{i+1}.r_id"
            where_clause += f"te{i+1}.r_id IS NULL\nAND "

        if exclude_blocks:
            sql += where_clause.rstrip("AND ")

        return sql

    # Construct the final SQL
    if clean_data_df['block_combo_logic'].iloc[0] == 'all blocks':
        all_sql = construct_final_sql(f"SELECT {select_clause} FROM ({combined_sql}) AS t1", exclude_blocks)
        final_sql = f"CREATE OR REPLACE TEMPORARY TABLE {query_id} AS (\n{all_sql}\n)"

    elif clean_data_df['block_combo_logic'].iloc[0] == 'any block':
        any_sql = construct_final_sql(f"SELECT {select_clause} FROM ({combined_sql}) AS t1", exclude_blocks)
        final_sql = f"CREATE OR REPLACE TEMPORARY TABLE {query_id} AS (\n{any_sql}\nGROUP BY {select_clause}\n)"

    return final_sql









def generate_final_sql(clean_data_df):
    ...
    # Rest of the code
    ...

    # Construct the final SQL
    if clean_data_df['block_combo_logic'].iloc[0] == 'all blocks':
        all_sql = construct_final_sql(f"SELECT DISTINCT * FROM ({combined_sql}) AS t1", exclude_blocks)
        final_sql = f"CREATE OR REPLACE TEMPORARY TABLE {query_id} AS (\n{all_sql}\n)"

    elif clean_data_df['block_combo_logic'].iloc[0] == 'any block':
        any_sql = construct_final_sql(f"SELECT DISTINCT * FROM ({combined_sql}) AS t1", exclude_blocks)
        final_sql = f"CREATE OR REPLACE TEMPORARY TABLE {query_id} AS (\n{any_sql}\n)"

    return final_sql
















