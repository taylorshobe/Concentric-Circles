
def generate_final_sql(clean_data_df):
    # Get unique block_ids
    block_ids = clean_data_df['block_id'].unique()
    query_key = clean_data_df['query_key'].iloc[0]
    
    # Extract the maximum number of phrase groups by checking the SELECT clause in `generate_and_near_sql`
    max_phrase_groups = max([i for block_id in block_ids for i in range(1, len(clean_data_df[clean_data_df['block_id'] == block_id]) + 1)])
    
    # Generate SQL for a specific block and phrase group
    def generate_block_pg_sql(block_id, pg_num):
        return textwrap.dedent(f"""
        SELECT 
            r_id, 
            '{block_id}' AS block_id, 
            '{pg_num}' AS pg, 
            block_id_{block_id}_t{pg_num}_pcd AS pcd, 
            block_id_{block_id}_t{pg_num}_seq AS seq, 
            block_id_{block_id}_t{pg_num}_utterance AS utterance
        FROM {block_id}_results
        """)
    
    # Generate the UNION SQL for all block_ids and phrase groups
    all_blocks_sql = []
    for block_id in block_ids:
        for pg_num in range(1, max_phrase_groups + 1):
            block_sql = generate_block_pg_sql(block_id, pg_num)
            all_blocks_sql.append(block_sql)

    # Create a CTE for intersection of all blocks
    cte_sql = textwrap.dedent(f"""
    WITH intersection AS (
        SELECT t1.r_id
        FROM A_results AS t1
        {" ".join([f"INNER JOIN {block_id}_results AS t{idx + 2} ON t1.r_id = t{idx + 2}.r_id" for idx, block_id in enumerate(block_ids[1:])])}
    )
    """)
    
    # Union all block SQLs
    union_sql = "\nUNION ALL\n".join(all_blocks_sql)
    
    # Final SQL using the CTE and UNIONed results
    final_sql = textwrap.dedent(f"""
    {cte_sql}
    CREATE OR REPLACE TEMPORARY TABLE q_891011121314 AS (
        SELECT * FROM (
            {union_sql}
        ) tmp
        INNER JOIN intersection
        ON tmp.r_id = intersection.r_id
    )
    """)
    
    return final_sql




