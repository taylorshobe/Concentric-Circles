
def generate_union_sql(inclusion_blocks):
    """
    Generates the UNION ALL SQL for the provided inclusionary blocks.
    """
    return "\nUNION ALL\n".join([f"SELECT * FROM {block}_transformed_results" for block in inclusion_blocks])

def generate_final_sql(clean_data_df, query_key):
    all_columns = ['T1.r_id', 'T1.block_id', 'T1.block_combo_logic', 'T1.phrase_group_id', 
                   'T1.phrase_operator', 'T1.pcd', 'T1.seq', 'T1.utterance']

    # Fetch block IDs directly from the DataFrame
    block_ids = clean_data_df['block_id'].unique().tolist()

    # Establishing lists for inclusionary and exclusionary blocks
    inclusion_blocks = []
    exclusion_blocks = []

    for block_id in block_ids:
        phrase_operator = clean_data_df[clean_data_df['block_id'] == block_id]['phrase_operator'].iloc[0]
        if phrase_operator == 'INCLUDE MATCHES':
            inclusion_blocks.append(block_id)
        else:
            exclusion_blocks.append(block_id)
    
    union_sql = generate_union_sql(inclusion_blocks)
    
    final_sql = f"""
CREATE OR REPLACE TEMPORARY TABLE {query_key} AS 
SELECT * 
FROM (
    {union_sql}
) T1
GROUP BY {', '.join(all_columns)}
    """

    logging.info(f"Generated SQL:\n{final_sql}")

    return final_sql
