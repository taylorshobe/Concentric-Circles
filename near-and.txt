
def generate_final_sql(cleaned_data_df):
    try:
        final_sql_list = []
        
        # Get the unique blocks in the data
        blocks = cleaned_data_df['block_id'].unique()
        query_key = cleaned_data_df['query_key'].iloc[0]

        # Split blocks into include and exclude groups
        include_blocks = [block_id for block_id in blocks if cleaned_data_df[cleaned_data_df['block_id'] == block_id]['phrase_operator'].values[0] == 'INCLUDE MATCHES']
        exclude_blocks = [block_id for block_id in blocks if cleaned_data_df[clean_data_df['block_id'] == block_id]['phrase_operator'].values[0] == 'EXCLUDE MATCHES']

        # Sort Blocks
        include_blocks.sort()
        exclude_blocks.sort()
        
        # Group by block_id to process each block of phrases
        for block_id, block_group in cleaned_data_df.groupby('block_id'):
            # Check if block has a single Phrase Group and is standalone
            is_standalone = block_group['standalone_pg'].iloc[0]
            prefix = "t1_" if is_standalone else ""
            
            # Identify the type of operator being used for the block
            if block_group['operator'].iloc[0].lower() == 'none':
                final_sql_list.append(generate_none_sql(block_group, block_id))
                
            elif block_group['operator'].iloc[0].lower() in ['and', 'near']:
                # We will be modifying the existing generate_and_near_sql function
                final_sql_list.append(generate_and_near_sql(block_group, block_id, prefix))
                
            else:
                for _, row in block_group.iterrows():
                    final_sql_list.append(generate_phrase_sql(row, block_id, prefix))
        
        # Return the final SQL based on the block combo logic
        if cleaned_data_df['block_combo_logic'].values[0] == 'ALL BLOCKS':
            # If all blocks must be combined, we will generate a UNION of all the SQLs
            final_sql = "\n\nUNION ALL\n\n".join(final_sql_list)
        else:
            # Otherwise, you'd generate the SQL based on specific logic you've determined for other 'block_combo_logic' values
            # Placeholder: Modify this part as per your requirement
            final_sql = "\n\n-- PLACEHOLDER FOR OTHER LOGIC --\n\n".join(final_sql_list)
        
        return final_sql
    except Exception as e:
        print(f"Error generating final SQL: {str(e)}")
        return None
