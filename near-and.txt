

def fetch_single_row_from_bq(table_name):
    """Fetch a single row from the specified BigQuery table."""
    sql = f"SELECT * FROM `{table_name}` LIMIT 1"
    return client.query(sql).to_dataframe()


def get_phrase_columns_count(df):
    """Function to get the number of phrase groups by counting 'phrase' columns in a DataFrame."""
    return len([col for col in df.columns if '_phrase' in col])


unique_block_ids = clean_data_df['block_id'].unique()
table_names = [f"{block_id}_results" for block_id in unique_block_ids]


for table in table_names:
    df = fetch_single_row_from_bq(table)
    
    phrase_col_count = get_phrase_columns_count(df)
    print(f"Number of phrase columns in {table}: {phrase_col_count}")







# Identify blocks with standalone phrase groups
single_phrase_blocks = clean_data_df[clean_data_df['standalone_pg']]

# For these blocks, we count all phrase groups, even if they are exclusionary
single_phrase_counts = single_phrase_blocks['block_id'].value_counts()

# Remove standalone phrase groups from the original dataframe
multi_phrase_blocks = clean_data_df[~clean_data_df['standalone_pg']]

# Filter out exclusionary phrase groups from non-standalone blocks
filtered_multi_phrase_blocks = multi_phrase_blocks[multi_phrase_blocks['phrase_operator'] != 'exclude matches']

# Count unique phrase_group_id values for each of the non-standalone block_id
multi_phrase_counts = filtered_multi_phrase_blocks.groupby('block_id')['phrase_group_id'].nunique()

# Combine the two series: single_phrase_counts and multi_phrase_counts
total_phrase_counts = pd.concat([single_phrase_counts, multi_phrase_counts])

for block_id, count in total_phrase_counts.items():
    print(f"Number of phrase groups in {block_id}_results: {count}")

base_columns = 4  # r_id, block_id, block_combo_logic, operator
columns_per_phrase_group = 4  # phrase_group_id, phrase_operator, seq, phrase

for block_id, count in total_phrase_counts.items():
    total_columns = base_columns + (count * columns_per_phrase_group)
    print(f"Expected number of columns in {block_id}_results: {total_columns}")





      
def standardize_temp_table(block_id, phrase_counts_dict):
    num_phrase_groups = phrase_counts_dict[block_id]
    
    union_selects = []
    for i in range(1, num_phrase_groups + 1):
        select_str = f"""
        SELECT 
            r_id,
            block_id,
            block_combo_logic,
            operator,
            t{i}_phrase_group_id AS phrase_group_id,
            t{i}_phrase_operator AS phrase_operator,
            t{i}_seq AS seq,
            t{i}_phrase AS phrase
        FROM `YOUR_PROJECT_ID.YOUR_DATASET.{block_id}_results`
        """
        union_selects.append(select_str.strip())
    
    final_sql = "\nUNION ALL\n".join(union_selects)
    
    return final_sql


final_sqls = {}
for block_id in block_ids:
    print(f"Processing block {block_id}")
    final_sqls[block_id] = standardize_temp_table(block_id, total_phrase_counts)












def standardize_temp_table(block_id, total_phrase_counts):
    num_phrase_groups = total_phrase_counts[block_id]
    
    union_selects = []
    for i in range(1, num_phrase_groups + 1):
        select_str = f"""
        SELECT 
            r_id,
            block_id,
            block_combo_logic,
            operator,
            t{i}_phrase_group_id AS phrase_group_id,
            t{i}_phrase_operator AS phrase_operator,
            t{i}_seq AS seq,
            t{i}_phrase AS phrase
        FROM `YOUR_PROJECT_ID.YOUR_DATASET.{block_id}_results`
        """
        union_selects.append(select_str.strip())
    
    final_sql = "\nUNION ALL\n".join(union_selects)
    
    # Create a new temp table with the transformed data
    new_table_name = f"{block_id}_transformed_results"
    create_table_sql = f"""
    CREATE OR REPLACE TABLE `YOUR_PROJECT_ID.YOUR_DATASET.{new_table_name}` AS {final_sql}
    """
    client.query(create_table_sql).result()  # Execute the creation of the new temp table

    print(f"Transformed data for block {block_id} saved as {new_table_name}")

    return final_sql





