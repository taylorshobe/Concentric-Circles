def generate_final_sql(clean_data_df):

    def construct_sql(base_query, include_blocks, join_type, additional_clause):
        # Construct the main SQL
        sql = f"{base_query}\n"

        # Handle included blocks
        if join_type == "UNION ALL":
            inclusions = "\n".join([f"{join_type}\nSELECT t1_r_id, t1_pcd, t1_seq, t1_utterance\nFROM {block_id}_results" for block_id in include_blocks[1:]])
        else:
            inclusions = "\n".join([f"{join_type}\n{block_id}_results AS t{i+2} ON t1.t1_r_id = t{i+2}.t1_r_id" for i, block_id in enumerate(include_blocks[1:])])
        sql += inclusions

        # Handle excluded blocks
        where_clause = "\nWHERE "
        for i, block_id in enumerate(exclude_blocks):
            sql += f"\nLEFT JOIN {block_id}_results AS te{i+1}\nON t1.t1_r_id = te{i+1}.t1_r_id"
            where_clause += f"te{i+1}.t1_r_id IS NULL\nAND "

        if exclude_blocks:
            sql += where_clause.rstrip("AND ")

        return f"{sql}{additional_clause}"

    # Begin main logic of generate_final_sql function

    # Get the unique blocks in the data
    blocks = clean_data_df['block_id'].unique()
    query_key = clean_data_df['query_key'].iloc[0]

    # Split blocks into include and exclude groups
    include_blocks = [block_id for block_id in blocks if clean_data_df[clean_data_df['block_id'] == block_id]['phrase_operator'].values[0] == 'INCLUDE MATCHES']
    exclude_blocks = [block_id for block_id in blocks if clean_data_df[clean_data_df['block_id'] == block_id]['phrase_operator'].values[0] == 'EXCLUDE MATCHES']

    # Sort Blocks
    include_blocks.sort()
    exclude_blocks.sort()

    # Check if any of the include Blocks are empty and return early if so
    if not include_blocks:
        print("No results found for the given Block ID. Exiting ...")
        return ""

    # Generate 'all' and 'any' SQL based on the definitions
    all_sql = construct_sql(
        base_query=f"SELECT t1.t1_r_id, t1.t1_pcd, t1.t1_seq, t1.t1_utterance\nFROM {include_blocks[0]}_results AS t1",
        include_blocks=include_blocks,
        join_type="INNER JOIN",
        additional_clause="\nGROUP BY t1_r_id, t1_pcd, t1_seq, t1_utterance"
    )

    any_sql = construct_sql(
        base_query=f"SELECT t1.t1_r_id, t1.t1_pcd, t1.t1_seq, t1.t1_utterance\nFROM {include_blocks[0]}_results AS t1",
        include_blocks=include_blocks,
        join_type="UNION ALL",
        additional_clause=""
    )

    # Return the final SQL based on the block combo logic
    if clean_data_df['block_combo_logic'].values[0] == 'ALL BLOCKS':
        final_sql = f"""CREATE OR REPLACE TEMPORARY TABLE {query_key} AS (\n\n{all_sql}\n)"""
        print(f"Generated 'all blocks' SQL:\n\n{final_sql}\n")
        return final_sql
    elif clean_data_df['block_combo_logic'].values[0] == 'ANY BLOCK':
        final_sql = f"""CREATE OR REPLACE TEMPORARY TABLE {query_key} AS (\nSELECT * FROM (\n\n{any_sql}\n) GROUP BY t1_r_id, t1_pcd, t1_seq, t1_utterance)\n"""
        print(f"Generated 'any block' SQL:\n\n{final_sql}\n")
        return final_sql
