def highlight_phrases(conversation, phrases_color_map):
    # Nested function to apply highlighting to a matched phrase
    # Separate logic for generating a highlighted Dash component from Main logic (identify and process matches). This helps make the code more modular and readable
    def apply_highlight(phrase, color):
        # Return a styled Dash component to highlight the phrase
        return html.Span(children=[html.Strong(phrase)], style={"color": color})

    # Initialize an empty list to store the resulting Dash components
    # This list will contain both the highlighted phrases and the unmatched parts of the conversation
    highlighted_components = []

    # This list will be used to store all matches we find in the conversation
    # Each item will be a tuple containing the start and end indices of the match, the matched phrase, and its color
    matches = []
    
    # Loop through each group of phrases and their associated colors in the provided map
    for phrase_group, color in phrases_color_map.items():
        # Split the phrase group into individual phrases (assuming they are comma-separated)
        for phrase in phrase_group.split(","):
            # Remove any leading or trailing whitespace from the phrase
            phrase = phrase.strip()
            
            # Use regex to find all occurrences of the current phrase in the conversation, ignoring case
            for match in re.finditer(r'{}'.format(phrase), conversation, flags=re.IGNORECASE):
                # Extract the start and end positions of the matched phrase
                start, end = match.span()
                # Add the details of this match to our matches list
                matches.append((start, end, phrase, color))

    # Now, we sort the matches by start position.
    # If two matches start at the same position (i.e., overlapping), we prioritize the longer match.
    matches.sort(key=lambda x: (x[0], -len(x[2])))

    # This variable keeps track of where we left off in the conversation after processing each match
    remaining_start_index = 0
    
    # Process each match, one by one
    for start, end, phrase, color in matches:
        # If the current match starts after our last processed position, we avoid overlapping matches
        if start >= remaining_start_index:
            # Append the text from our last processed position up to the start of this match
            # This text is not highlighted
            highlighted_components.append(conversation[remaining_start_index:start])
            
            # Now, append the matched phrase with highlighting
            highlighted_components.append(apply_highlight(phrase, color))
            
            # Update our last processed position to the end of the current match
            remaining_start_index = end

    # After processing all matches, there might be some remaining text in the conversation that comes after the last match
    # We append this text without highlighting
    highlighted_components.append(conversation[remaining_start_index:])
    
    # Return the list of components, which now contains both highlighted and non-highlighted parts of the conversation
    return highlighted_components
