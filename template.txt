
import dash
from dash import html, dcc, callback, Input, Output, State, no_update
import dash_bootstrap_components as dbc
import dash_more_components as dmc
from datetime import date, timedelta
import logging

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

app.layout = html.Div([
    dbc.Row([
        dbc.Col([
            # Selection method: Single Date or Date Range
            dbc.RadioItems(
                options=[
                    {'label': 'Single Date', 'value': 'single'},
                    {'label': 'Date Range', 'value': 'range'}
                ],
                value='range',
                id='date-selection-method',
                inline=True
            ),

            # Container for dynamically displaying either Single DatePicker or DateRangePicker
            html.Div(id='date-picker-container'),

        ], width=3)
    ])
])

@app.callback(
    Output('date-picker-container', 'children'),
    [Input('date-selection-method', 'value')]
)
def update_date_picker(selection_method):
    if selection_method == 'single':
        return dmc.DatePickerSingle(
            id='single-date-picker',
            date=date.today() - timedelta(7),
            min_date=date.today() - timedelta(90),
            max_date=date.today() - timedelta(2),
            clearable=False,
            persistence=True
        )
    else:
        return dmc.DateRangePicker(
            id='query-date-range',
            min_date=date.today() - timedelta(90),
            max_date=date.today() - timedelta(2),
            start_date=date.today() - timedelta(7),
            end_date=date.today() - timedelta(1),
            clearable=False,
            persistence=True
        )

@app.callback(
    Output("storage", "data"),
    Output("scope-set-alert", 'is_open'),
    Output('loading-scope-output', 'children'),
    Output('scope-status', "value"),
    [Input("scope-set-button", "n_clicks")],
    [State("query-date-range", "value"),
     State("single-date-picker", "date"),
     State("storage", "data")]
)
def run_query_process(n_clicks, query_date_range, single_date, memory_scope):

    int = dash.callback_context.triggered[0]["prop_id"].split(".")[0]
    logging.info(f"Set Query Scope: triggering int: {int}") 

    if memory_scope is None:
        scope_data = {
            'last_set': '',
            'last_set_by': '',
            'scope_set': False
        }
        return scope_data, False, no_update, no_update
    elif int == "scope-set-button" and n_clicks is not None:

        # Check if single date is selected and handle accordingly
        if single_date:
            min_date = single_date
            max_date = single_date
        else:
            min_date = query_date_range[0]
            max_date = query_date_range[1]

        # Further processing for the date selection goes here...

if __name__ == "__main__":
    app.run_server(debug=True)






import dash
from dash import html, dcc, callback, Input, Output, State, no_update
import dash_bootstrap_components as dbc
import dash_more_components as dmc
from datetime import date, timedelta
import logging

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

app.layout = html.Div([
    dbc.Row([
        dbc.Col([
            # Query date range
            html.Div([
                dbc.Label("Date Range", html_for="size"),
                html.Br(),
                dmc.DateRangePicker(
                    id='query-date-range',
                    min_date=date.today() - timedelta(90),
                    max_date=date.today() - timedelta(2),
                    start_date=date.today() - timedelta(7),
                    end_date=date.today() - timedelta(1),
                    clearable=False,
                    persistence=True
                ),
            ], className="mt-2"),
        ], width=3)
    ])
])

@app.callback(
    Output('query-date-range', 'end_date'),
    [Input('query-date-range', 'start_date'),
     Input('query-date-range', 'end_date')]
)
def set_end_date_if_missing(start_date, end_date):
    # If a start date is chosen but no end date, set end date to start date
    if start_date and not end_date:
        return start_date
    # Otherwise, don't change the end date
    return dash.no_update

@app.callback(
    Output("storage", "data"),
    Output("scope-set-alert", 'is_open'),
    Output('loading-scope-output', 'children'),
    Output('scope-status', "value"),
    [Input("scope-set-button", "n_clicks")],
    [State("query-date-range", "value"),
     State("storage", "data")]
)
def run_query_process(n_clicks, query_date_range, memory_scope):
    int = dash.callback_context.triggered[0]["prop_id"].split(".")[0]
    logging.info(f"Set Query Scope: triggering int: {int}")

    if memory_scope is None:
        scope_data = {
            'last_set': '',
            'last_set_by': '',
            'scope_set': False
        }
        return scope_data, False, no_update, no_update
    elif int == "scope-set-button" and n_clicks is not None:
        min_date = query_date_range[0]
        max_date = query_date_range[1]
        # Continue your further processing with min_date and max_date...

if __name__ == "__main__":
    app.run_server(debug=True)







