import textwrap

def generate_and_near_sql(group, block_id):
    block_combo_logic = group['block_combo_logic'].iloc[0]
    block_operator = group['operator'].iloc[0]

    # Loop over each row in the group and generate a SQL query
    include_sql_queries = []
    exclude_sql_queries = []

    for i, row in group.iterrows():
        phrase_group_id = row['phrase_group_id']
        # Safely get the standalone_pg value for the current row
        standalone_pg = row.get('standalone_pg', False)
        sql = generate_phrase_sql(row, block_id, phrase_group_id, standalone_pg)

        # Proximity Condition for "NEAR" operator
        prox_seconds = float(row['proximity']) if row['proximity'] else None
        prox_m_seconds = prox_seconds * 1000 if prox_seconds else None

        if row['phrase_operator'].lower() == 'include matches':
            # Add the SQL query to the include list
            include_sql_queries.append(sql)

        elif row['phrase_operator'].lower() == 'exclude matches' and any(group['phrase_operator'].str.lower() == 'include matches'):
            # Add the SQL query to the exclude list only if there's at least one 'include matches' in the same block
            exclude_sql_queries.append(sql)

    # Join all include queries into one
    if include_sql_queries:
        include_subqueries = [f"({sql}) AS t{i}\n" for i, sql in enumerate(include_sql_queries, start=1)]
        
        if len(include_subqueries) > 1:
            if block_operator.lower() == 'and':
                join_condition = ' '.join(f'\nINNER JOIN\n\n{subquery} \nON t1.r_id = t{i+1}.r_id' for i, subquery in enumerate(include_subqueries[1:], start=1))
            elif block_operator.lower() == 'near':
                join_condition = ' '.join(f'\nINNER JOIN\n\n{subquery} \nON t1.r_id = t{i+1}.r_id \nAND ABS(t1.seq - t{i+1}.seq) <= {prox_m_seconds}' for i, subquery in enumerate(include_subqueries[1:], start=1))
        else:
            join_condition = ''
        from_clause = f"FROM {include_subqueries[0]} {join_condition}"
    else:
        from_clause = ""

    # Handle exclude matches
    if exclude_sql_queries:
        if block_operator.lower() == 'and':
            exclude_on_conditions = ' '.join([f'\nLEFT JOIN {subquery} ON t1.r_id = te{i}.r_id' for i, subquery in enumerate(exclude_sql_queries, start=1)])
            where_condition = f'WHERE {" AND ".join([f"te{i}.r_id IS NULL" for i in range(1, len(exclude_sql_queries) + 1)])}'

        elif block_operator.lower() == 'near':
            exclude_on_conditions = ' '.join([f'\nLEFT JOIN {subquery} ON t1.r_id = te{i}.r_id AND ABS(t1.seq - te{i}.seq) <= {prox_m_seconds}' for i, subquery in enumerate(exclude_sql_queries, start=1)])
            where_condition = f'WHERE {" AND ".join([f"te{i}.r_id IS NULL" for i in range(1, len(exclude_sql_queries) + 1)])}'

    else:
        exclude_on_conditions = ""
        where_condition = ""

    columns_list = [f"t{i+1}.{col} AS t{i+1}_{col}" for i in range(len(include_subqueries)) for col in ['phrase_group_id', 'phrase_operator', 'pcd', 'seq', 'utterance']]
    columns = ',\n'.join(columns_list)

    # Construct the final SQL
    final_sql = textwrap.dedent(f"""
SELECT
  t1.r_id
, '{block_id}' AS block_id
, '{block_combo_logic}' AS block_combo_logic
, {columns}
{from_clause}
{exclude_on_conditions}
{where_condition}
    """)

    return final_sql
